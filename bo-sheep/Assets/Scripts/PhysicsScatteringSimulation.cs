using System.Collections.Generic;
using UnityEngine;
using System.Linq;

public class PhysicsScatteringSimulation : MonoBehaviour
{
	public int maxIterations = 1000;
	SimulatedBody[] simulatedBodies;

	public Vector2 forceMinMax;
	public float forceAngleInDegrees;
	public bool randomiseForceAngle;

	List<Rigidbody> generatedRigidbodies;
	List<Collider> generatedColliders;

	[ContextMenu("Run Simulation")]
	public void RunSimulation()
	{
		AutoGenerateComponents();

		simulatedBodies = FindObjectsOfType<Rigidbody>().Select(rb => new SimulatedBody(rb, rb.transform.IsChildOf(transform))).ToArray();

		foreach (SimulatedBody body in simulatedBodies)
		{
			if(body.isSimulated)
			{
				float randomForceAmount = Random.Range(forceMinMax.x, forceMinMax.y);
				float forceAngle = (randomiseForceAngle ? Random.Range(0f, 360f) : forceAngleInDegrees) * Mathf.Deg2Rad;

				Vector3 forceDirection = new Vector3(Mathf.Sin(forceAngle), 0, Mathf.Cos(forceAngle));
				body.rigidbody.AddForce(forceDirection * randomForceAmount, ForceMode.Impulse);
			}
		}
		
		Physics.autoSimulation = false;

		for (int i = 0; i < maxIterations; i++) {
			Physics.Simulate (Time.fixedDeltaTime);

			if (simulatedBodies.All(sb => sb.rigidbody.IsSleeping() || !sb.isSimulated))
			{
				print(i);
				break;
			}
		}

		Physics.autoSimulation = true;

		foreach (SimulatedBody body in simulatedBodies)
		{
			if (!body.isSimulated)
			{
				body.Reset();
			}
		}

		RemoveAutoGeneratedComponents();
	}

	/**
	 * For any children of the transform, if they don't have Rigidbodies or
	 * colliders, give them some auto-created ones and keep lists of the
	 * auto-created ones so we can destroy them at the end of the simulation
	 * and leave everything as we found it
	 */
	void AutoGenerateComponents()
	{
		generatedRigidbodies = new List<Rigidbody>();
		generatedColliders = new List<Collider>();

		foreach(Transform child in transform)
		{
			if (!child.GetComponent<Rigidbody>())
			{
				generatedRigidbodies.Add(child.gameObject.AddComponent<Rigidbody>());
			}

			if (!child.GetComponent<Collider>())
			{
				generatedColliders.Add(child.gameObject.AddComponent<BoxCollider>());
			}
		}
	}

	/**
	 * Delete all rigidbodies and colliders that have been generated by
	 * AutoGenerateComponents()
	 */
	void RemoveAutoGeneratedComponents()
	{
		foreach (Rigidbody rb in generatedRigidbodies)
		{
			DestroyImmediate(rb);
		}

		foreach (Collider c in generatedColliders)
		{
			DestroyImmediate(c);
		}
	}

	[ContextMenu("Reset")]
	public void ResetAllBodies()
	{
		if (simulatedBodies != null)
		{
			foreach(SimulatedBody body in simulatedBodies)
			{
				body.Reset();
			}
		}
	}

	struct SimulatedBody
	{
		public readonly Rigidbody rigidbody;
		readonly Vector3 originalPosition;
		readonly Quaternion originalRotation;
		readonly Transform transform;
		public readonly bool isSimulated;

		public SimulatedBody(Rigidbody rigidbody, bool isSimulated)
		{
			this.rigidbody = rigidbody;
			transform = rigidbody.transform;
			originalPosition = rigidbody.position;
			originalRotation = rigidbody.rotation;
			this.isSimulated = isSimulated;
		}

		public void Reset()
		{
			transform.position = originalPosition;
			transform.rotation = originalRotation;

			if (rigidbody != null)
			{
				rigidbody.velocity = Vector3.zero;
				rigidbody.angularVelocity = Vector3.zero;
			}
		}
	}
}
